---
// src/components/HybridResources.astro
import ResourceCard from './ResourceCard.astro';
import { getCollection } from 'astro:content';

// Get blog posts from content collections
const getBlogPosts = async () => {
  try {
    const blogPosts = await getCollection('blog');
    
    return blogPosts.map(post => ({
      title: post.data.title,
      description: post.data.description,
      image: post.data.featuredImage,
      type: 'blog',
      date: post.data.publishDate,
      link: `/blog/${post.slug}`,
      linkText: 'Read article'
    }));
  } catch (error) {
    console.error("Error loading blog posts:", error);
    return [];
  }
};

// Import videos directly from the video page
// This allows us to have a single source of truth for videos
import { videoContent } from '../pages/videos/index.astro';

// Convert video page content to resource format
const videoResources = videoContent.map(video => ({
  title: video.title,
  description: video.description,
  type: "video",
  date: typeof video.date === 'string' ? video.date : "2025-01-01", // Ensure date is in string format
  duration: video.duration,
  // Set link to "#" so it doesn't navigate away - video will open in modal
  link: "#",
  linkText: "Watch video",
  videoId: video.videoId,
  presenter: video.presenter, // Add presenter information
  // Generate thumbnail from YouTube
  image: `https://img.youtube.com/vi/${video.videoId}/maxresdefault.jpg`
}));

// Get blog posts
const blogPosts = await getBlogPosts();

// Combine blog posts and videos
const allResources = [...blogPosts, ...videoResources];

// Sort by date (newest first)
const sortedResources = allResources.sort((a, b) => {
  const dateA = typeof a.date === 'string' ? new Date(a.date) : a.date;
  const dateB = typeof b.date === 'string' ? new Date(b.date) : b.date;
  return dateB.getTime() - dateA.getTime();
});

// Log for debugging
console.log(`Total resources: ${allResources.length}, Videos: ${videoResources.length}, Blogs: ${blogPosts.length}`);
---

<section id="resources" class="py-20 px-6 md:px-12 bg-gray-50">
  <div class="container mx-auto max-w-6xl">
    <div class="text-center mb-16">
      <h2 class="text-4xl font-bold mb-4 section-heading">Educational Resources</h2>
      <p class="text-gray-600 max-w-3xl mx-auto text-lg">
        Access practical guides, research findings, and tools to implement microbiome-focused nutrition strategies.
      </p>
    </div>
    
    <!-- Carousel container -->
    <div class="relative">
      <!-- Previous/Next buttons for larger screens -->
      <button id="prevBtn" class="absolute left-0 top-1/2 transform -translate-y-1/2 -translate-x-5 z-10 bg-white rounded-full p-2 shadow-md hidden md:block focus:outline-none hover:bg-gray-100">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>
      
      <button id="nextBtn" class="absolute right-0 top-1/2 transform -translate-y-1/2 translate-x-5 z-10 bg-white rounded-full p-2 shadow-md hidden md:block focus:outline-none hover:bg-gray-100">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
      
      <!-- Carousel track - pre-set the width for more stability -->
      <div id="carouselTrack" class="flex transition-transform duration-300 ease-out overflow-x-scroll md:overflow-x-hidden snap-x snap-mandatory scroll-smooth">
        {sortedResources.map((resource, index) => (
          <div class="flex-none w-full md:w-1/3 px-4 snap-start">
            <ResourceCard 
              title={resource.title}
              description={resource.description}
              image={resource.image}
              type={resource.type}
              duration={resource.duration}
              link={resource.link}
              linkText={resource.linkText || (resource.type === 'video' ? 'Watch video' : 'Read article')}
              delay={index * 0.2}
              videoId={resource.videoId}
              date={resource.date instanceof Date ? resource.date.toISOString() : resource.date}
              presenter={resource.presenter}
            />
          </div>
        ))}
      </div>
      
      <!-- Dots for mobile -->
      <div class="flex justify-center mt-6 space-x-2 md:hidden">
        {sortedResources.map((_, index) => (
          <button class="carousel-dot w-3 h-3 rounded-full bg-gray-300 focus:outline-none" data-index={index}></button>
        ))}
      </div>
    </div>
  </div>
</section>

<!-- Video Modal -->
<div id="resourcesVideoModal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden items-center justify-center">
  <div class="bg-white rounded-lg w-full max-w-4xl mx-4 sm:mx-auto p-1 relative">
    <!-- Close button -->
    <button id="closeResourcesVideoModal" class="absolute -top-10 right-0 text-white text-xl hover:text-gray-300 focus:outline-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>
    
    <!-- Video container with 16:9 aspect ratio -->
    <div class="relative" style="padding-bottom: 56.25%;">
      <iframe id="resourcesVideoFrame" class="absolute top-0 left-0 w-full h-full rounded-lg" 
              frameborder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
              allowfullscreen>
      </iframe>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // DEBUG - log the number of resources found at runtime
    console.log("Resource cards found:", document.querySelectorAll('.resource-card').length);
    console.log("Video resources:", document.querySelectorAll('.resource-card[data-type="video"]').length);
    
    // Video modal functionality
    const resourcesVideoModal = document.getElementById('resourcesVideoModal');
    const resourcesVideoFrame = document.getElementById('resourcesVideoFrame');
    const closeResourcesVideoModal = document.getElementById('closeResourcesVideoModal');
    
    // Initialize video cards in resources section - MUST run after DOM is fully loaded
    function initializeVideoCards() {
      // Get all video cards in the resources section
      const resourceVideoCards = document.querySelectorAll('#resources .resource-card[data-type="video"]');
      const resourceVideoLinks = document.querySelectorAll('#resources .resource-card[data-type="video"] a');
      
      console.log("Found", resourceVideoCards.length, "video cards in resources section");
      
      // Make video cards clickable to open modal
      resourceVideoCards.forEach(card => {
        // Make the card style cursor pointer for better UX
        card.style.cursor = 'pointer';
        
        // Make the entire card clickable
        card.addEventListener('click', function(e) {
          // Ignore clicks on links or buttons
          if (e.target.closest('a') || e.target.closest('button')) {
            return;
          }
          
          const videoId = this.getAttribute('data-video-id');
          if (videoId) {
            e.preventDefault();
            openResourcesVideoModal(videoId);
          }
        });
      });
      
      // Make watch video links open the modal
      resourceVideoLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          const card = this.closest('.resource-card');
          const videoId = card.getAttribute('data-video-id');
          if (videoId) {
            openResourcesVideoModal(videoId);
          }
        });
      });
    }
    
    // Function to open video modal
    function openResourcesVideoModal(videoId) {
      if (resourcesVideoFrame && resourcesVideoModal) {
        resourcesVideoFrame.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
        resourcesVideoModal.classList.remove('hidden');
        resourcesVideoModal.classList.add('flex');
        document.body.style.overflow = 'hidden';
      }
    }
    
    // Function to close video modal
    function closeResourcesVideoModalFunc() {
      if (resourcesVideoFrame && resourcesVideoModal) {
        resourcesVideoModal.classList.add('hidden');
        resourcesVideoModal.classList.remove('flex');
        resourcesVideoFrame.src = '';
        document.body.style.overflow = '';
      }
    }
    
    // Add event listener to close button
    if (closeResourcesVideoModal) {
      closeResourcesVideoModal.addEventListener('click', closeResourcesVideoModalFunc);
    }
    
    // Close when clicking outside the video
    if (resourcesVideoModal) {
      resourcesVideoModal.addEventListener('click', function(e) {
        if (e.target === this) {
          closeResourcesVideoModalFunc();
        }
      });
    }
    
    // Close modal with ESC key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && resourcesVideoModal && !resourcesVideoModal.classList.contains('hidden')) {
        closeResourcesVideoModalFunc();
      }
    });

    // *** FIXED CAROUSEL FUNCTIONALITY ***
    const track = document.getElementById('carouselTrack');
    if (track) {
      const slides = Array.from(track.children);
      
      // IMPORTANT: Exit if no slides
      if (slides.length === 0) {
        console.error("No slides found in carousel");
        return;
      }
      
      // Save the number of slides to prevent changes later
      const slideCount = slides.length;
      console.log("Initial slides count:", slideCount);
      
      const nextButton = document.getElementById('nextBtn');
      const prevButton = document.getElementById('prevBtn');
      const dotsContainer = document.querySelector('#resources .flex.justify-center.mt-6');
      const dots = dotsContainer ? Array.from(dotsContainer.querySelectorAll('.carousel-dot')) : [];
      
      let currentIndex = 0;
      
      // Pre-calculate slide width to avoid reflow issues
      const containerWidth = track.parentElement.clientWidth;
      const slideWidth = containerWidth / (window.innerWidth >= 768 ? 3 : 1);
      
      console.log("Container width:", containerWidth, "Slide width:", slideWidth);
      
      // Pre-set widths for more stability
      slides.forEach(slide => {
        slide.style.width = `${slideWidth}px`;
      });
      
      // Initialize dots
      if (dots.length > 0) {
        dots[0].classList.add('bg-blue-500');
        dots[0].classList.remove('bg-gray-300');
      }
      
      // Set slide positions
      function setSlidePosition() {
        slides.forEach((slide, index) => {
          slide.style.transform = `translateX(${index * 100}%)`;
        });
      }
      
      setSlidePosition();
      
      // Move to slide - more robust implementation
      function moveToSlide(targetIndex) {
        // Ensure we haven't lost any slides
        if (slides.length !== slideCount) {
          console.error("Slide count changed! Expected:", slideCount, "Found:", slides.length);
          // Re-get the slides array to be safe
          const updatedSlides = Array.from(track.children);
          if (updatedSlides.length > 0) {
            slides.length = 0;
            updatedSlides.forEach(slide => slides.push(slide));
          }
        }
        
        // Validate target index
        if (targetIndex < 0) {
          targetIndex = slides.length - 1;
        } else if (targetIndex >= slides.length) {
          targetIndex = 0;
        }
        
        currentIndex = targetIndex;
        
        // Update track transform using calculated width
        track.style.transform = `translateX(-${currentIndex * slideWidth}px)`;
        
        // Update dots
        dots.forEach((dot, index) => {
          if (index === currentIndex) {
            dot.classList.add('bg-blue-500');
            dot.classList.remove('bg-gray-300');
          } else {
            dot.classList.add('bg-gray-300');
            dot.classList.remove('bg-blue-500');
          }
        });
      }
      
      // Next button event
      if (nextButton) {
        nextButton.addEventListener('click', () => {
          moveToSlide(currentIndex + 1);
          // Re-initialize video cards in case they got detached
          setTimeout(initializeVideoCards, 100);
        });
      }
      
      // Prev button event
      if (prevButton) {
        prevButton.addEventListener('click', () => {
          moveToSlide(currentIndex - 1);
          // Re-initialize video cards in case they got detached
          setTimeout(initializeVideoCards, 100);
        });
      }
      
      // Dot navigation
      dots.forEach((dot, index) => {
        dot.addEventListener('click', () => {
          moveToSlide(index);
          // Re-initialize video cards in case they got detached
          setTimeout(initializeVideoCards, 100);
        });
      });
      
      // Handle swipe for mobile
      let touchStartX = 0;
      let touchEndX = 0;
      
      track.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
      });
      
      track.addEventListener('touchend', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
      });
      
      function handleSwipe() {
        const swipeThreshold = 50;
        if (touchEndX < touchStartX - swipeThreshold) {
          // Swipe left - go next
          moveToSlide(currentIndex + 1);
          // Re-initialize video cards in case they got detached
          setTimeout(initializeVideoCards, 100);
        } else if (touchEndX > touchStartX + swipeThreshold) {
          // Swipe right - go prev
          moveToSlide(currentIndex - 1);
          // Re-initialize video cards in case they got detached
          setTimeout(initializeVideoCards, 100);
        }
      }
      
      // More robust window resize handler
      let resizeTimeout;
      window.addEventListener('resize', () => {
        // Debounce for better performance
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          // Recalculate dimensions
          const newContainerWidth = track.parentElement.clientWidth;
          const newSlideWidth = newContainerWidth / (window.innerWidth >= 768 ? 3 : 1);
          
          // Update slide widths
          slides.forEach(slide => {
            slide.style.width = `${newSlideWidth}px`;
          });
          
          // Update track position
          track.style.transform = `translateX(-${currentIndex * newSlideWidth}px)`;
          
          // Re-initialize video cards
          initializeVideoCards();
        }, 250);
      });
    }
    
    // Use a more robust initialization approach with retries
    let initAttempts = 0;
    const maxAttempts = 5;
    
    function initializeWithRetry() {
      initAttempts++;
      console.log(`Initializing video cards, attempt ${initAttempts}...`);
      
      // Initialize video cards
      initializeVideoCards();
      
      // Check if we found any video cards
      const videoCards = document.querySelectorAll('#resources .resource-card[data-type="video"]');
      console.log(`Found ${videoCards.length} video cards on attempt ${initAttempts}`);
      
      // If we didn't find any video cards and we haven't reached the max attempts, try again
      if (videoCards.length < 2 && initAttempts < maxAttempts) {
        // Try again after a delay, with increasing wait times
        setTimeout(initializeWithRetry, 300 * initAttempts);
      }
    }
    
    // Start initialization immediately
    initializeWithRetry();
    
    // Also initialize again after a delay to be extra safe
    setTimeout(initializeWithRetry, 1000);
    
    // For debugging - add a way to check videos after page load
    window.checkVideoCards = function() {
      const videoCards = document.querySelectorAll('#resources .resource-card[data-type="video"]');
      console.log("Video cards:", videoCards.length);
      return videoCards.length;
    };
  });
</script>